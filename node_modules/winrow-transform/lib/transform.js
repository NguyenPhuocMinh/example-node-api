'use strict';

const winrow = require('winrow');
const {
  Promise,
  lodash,
  app,
  router,
  getRequestId,
} = winrow;
const middleware = require('../utils/middleware');
const loggingFactory = require('winrow-logger');
const { get, isEmpty, isArray } = lodash;
const { name, version } = require('../package.json');

function TransForm() {
  const requestId = getRequestId();
  // mapping api
  this.mapping = function (sandbox) {
    const pathServer = get(sandbox, 'application.pathServer');
    const mappings = get(sandbox, 'application.mappings');
    return new Promise((resolve, reject) => {
      if (!isEmpty(mappings) && isArray(mappings)) {
        mappings.map(mapping => {
          const method = get(mapping, 'method')
          const pathName = get(mapping, 'pathName');
          const serviceName = get(mapping, 'serviceName');
          const methodName = get(mapping, 'methodName');
          const input = get(mapping, 'input') || {};
          const output = get(mapping, 'output') || {};
          const serviceMethod = serviceName[methodName];

          switch (method) {
            case 'GET':
              return app.use(pathServer, router.get(pathName, (req, res) =>
                middleware(req, res, input, output, serviceMethod)
              ));
            case 'POST':
              return app.use(pathServer, router.post(pathName, (req, res) =>
                middleware(req, res, input, output, serviceMethod)
              ));
            case 'PUT':
              return app.use(pathServer, router.put(pathName, (req, res) =>
                middleware(req, res, input, output, serviceMethod)
              ));
            case 'DELETE':
              return app.use(pathServer, router.delete(pathName, (req, res) =>
                middleware(req, res, input, output, serviceMethod)
              ));
            default:
              return null;
          }
        })
      }
      resolve(app);
    })
      .then(info => {
        loggingFactory.warn(`Connect library ${name} version : ${version} has complete`, {
          labelName: `[${name}]`,
          requestId: `${requestId}`
        })
        return info;
      })
      .catch(err => {
        loggingFactory.error(`Mapping has error : ${err}`, {
          labelName: `[${name}]`,
          requestId: `${requestId}`
        })
        return Promise.reject(err);
      })
  }
};

module.exports = new TransForm();