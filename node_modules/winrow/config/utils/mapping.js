/*!
 * winrow
 * Copyright(c) 2020 create node js with microservices
 * MIT Licensed
 */

'use strict';

const Promise = require('bluebird');
const lodash = require('lodash');
const handle = require('../middleware/handle');
const loggingFactory = require('winrow-logger');
const requestId = require('../supports/requestId');
const dataStore = require('../utils/dataStore');
const returnCodes = require('../supports/returnCodes');
const { get, isEmpty, isArray, isObject } = lodash;

function mapping(params = {}) {
  const { app, router, path_server, mappings } = params;

  const paramService = {
    dataStore: dataStore,
    returnCodes: returnCodes,
  };

  return new Promise((resolve, reject) => {
    if (!isEmpty(mappings) && isArray(mappings)) {
      mappings.map(mapping => {
        const method = get(mapping, 'method')
        const pathName = get(mapping, 'pathName');
        const serviceName = get(mapping, 'serviceName');
        const methodName = get(mapping, 'methodName');
        const input = get(mapping, 'input') || {};
        const output = get(mapping, 'output') || {};
        const service_method = serviceName[methodName];

        if (isObject(serviceName)) {
          serviceName['init'](paramService);
        };

        switch (method) {
          case 'GET':
            return app.use(path_server, router.get(pathName, (req, res) =>
              handle({ req, res, input, output, service_method })
            ));
          case 'POST':
            return app.use(path_server, router.post(pathName, (req, res) =>
              handle({ req, res, input, output, service_method })
            ));
          case 'PUT':
            return app.use(path_server, router.put(pathName, (req, res) =>
              handle({ req, res, input, output, service_method })
            ));
          case 'DELETE':
            return app.use(path_server, router.delete(pathName, (req, res) =>
              handle({ req, res, input, output, service_method })
            ));
          default:
            return null;
        }
      })
    }
    resolve(app);
  })
    .then(info => {
      loggingFactory.warn(`Connect mapping has complete`, {
        requestId: `${requestId}`
      })
      return info;
    })
    .catch(err => {
      loggingFactory.error(`Mapping has error : ${err}`, {
        requestId: `${requestId}`
      })
      return Promise.reject(err);
    });
};

module.exports = mapping;